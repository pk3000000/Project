value type 정리
-------------------------------------------------------------
1. bool (true, false)

System.Boolean의 별칭. true와 false값을 가질 수 있다.


참고 -

null값을 가질 수 있는 부울 변수가 필요할 경우 bool?를 사용.


변환 -

C++에서는 false == 0, true == 0이 아닌값과 같지만 C#에서는 bool형식과 다른 형식 같의 변환이 없음.

예제 -

IsLetter - 영문자, IsLower - 대소문자  등의 검사 하는 method에서 bool 값을 반환.

------------------------------------------------------------------
2. byte (부호가 없는 정수형)

범위 0 ~ 255  부호 없는 8비트 정수

255가 넘으면 compile error

byte x = 10, y = 20;
byte z = x + y; 

에서 산술식이 기본적으로 int로 계산 되므로

byte z = (byte)(x+y);

로 캐스트를 사용 해야 한다.

대상 변수의 저장소 크기가 같거나 더 크면

int x = 10, y = 20;
long n = x + y;

사용 가능.

그러나 부동 소수점 형식에서 byte 로의 암시적 캐스트가 없으므로

byte y = (byte)3.0;

으로 하여 명시적 캐스트를 해주어야 한다.


오버로드 된 메서드 호출 시

SampleMethod((byte)5); // 5라는 상수는 일반적으로 int형으로 취급 되므로 암시적 캐스트를 해주어야 byte로 인식한다.

-------------------------------------------------------------------------
3. char (문자형)

유니코드로 16비트 숫자 값. 대부분의 전세계 언어를 나타내는 데 사용 됨.

문자형 'X', 16진수 '\x0058', Asciicode (char)88, Unicode '\u0058'은 모두 'X'를 반환한다.


변환 -

ushort, int, uint, long, ulong, float, double, decimal로 암시적 변환을 할 수 있지만 다른 형식에서 char형식으로의

암시적 변환은 없음.

--------------------------------------------------------------------------
4. decimal (128bit 정수 및 실수형)

근사 범위 - (-7.9 X 10(28) - 7.9 X 10(28)) / (10(0 - 28))

decimal 처리 되게 하려면 접미사 m 사용. m이 없으면 double형으로 인식하여 컴파일 에러 발생. 예) 300.5m

-변환

정수 계열 type은 암시적으로 deciaml로 변환

decimal myMoney = 300;

부동 소수점 type과 decimal 사이에는 명시적으로 변환해 주어야 한다.

Console.WriteLine(dec + dub); <== double type과 decimal type간의 연산은 허용되지 않음.

: 오류 - Operator '+' cannot be applied to operands of type 'double' and 'decimal'


Console.WriteLine(dec + (decimal)dub);  
Console.WriteLine((double)dec + dub);

이런 식으로 한쪽으로 명시적 캐스팅을 해주어야 함.
----------------------------------------------------------------------------
5. double (실수형)

double x = 3d; 또는 x = 3D;

변환 -

부동소수점 둘 중 하나가 double이면 double로 계산, 부울식 또는 관계식에서는 bool형으로 계산.

double type이 없는 경우 float형으로 계산. 부울식 또는 관계식에서는 bool형으로 계산.


부동 소수점 식에 포함될 수 있는 것.

 - 양수 및 음수 0
 - 양수 및 음수 무한
 - NaN(Not-a-Number)값 : 숫자가 아닌 값
 - 0이 아닌 값의 유한 집합

------------------------------------------------------------------------------
6. enum (열거형)

같은 종류의 상수를 명명하여 의미를 부여하여 사용할 수 있다.

네임스페이스로 사용하는 것이 일반적이나 특정 클래스, 구조체 내에 열거형이 중첩될 수도 있다.

enum Days {Sat, Sun, Mon, Tue, Wed, Thu, Fri}; // 첫번째 값이 0

enum Days {Sat=1, Sun, Mon, Tue, Wed, Thu, Fri}; // 첫번째 값이 1

enum Days : byte {Sat=1, Sun, Mon, Tue, Wed, Thu, Fri};  // default가 int형이지만 byte형으로 선언

열거형으로 승인된 type은 byte, sbyte, short, ushort, int, uint, long 또는 ulong이 있다.

int x = (int)Days.Sun;  // 열거형은 명시적 캐스팅으로 정수형으로 변환 가능 하다.

public class EnumTest2
{
    enum Range : long { Max = 2147483648L, Min = 255L };
    static void Main()
    {
        long x = (long)Range.Max;
        long y = (long)Range.Min;
        Console.WriteLine("Max = {0}", x);
        Console.WriteLine("Min = {0}", y);
    }
}

클래스 변수처럼 사용 가능하여 특정 상수 값을 대입하여 사용 가능하다.

[Flags]
public enum CarOptions
{
    // The flag for SunRoof is 0001.
    SunRoof = 0x01,
    // The flag for Spoiler is 0010.
    Spoiler = 0x02,
    // The flag for FogLights is 0100.
    FogLights = 0x04,
    // The flag for TintedWindows is 1000.
    TintedWindows = 0x08,
}

class FlagTest
{
   static void Main()
   {
        // The bitwise OR of 0001 and 0100 is 0101.
        CarOptions options = CarOptions.SunRoof | CarOptions.FogLights;

        // Because the Flags attribute is specified, Console.WriteLine displays
        // the name of each enum element that corresponds to a flag that has
        // the value 1 in variable options.
        Console.WriteLine(options);
        // The integer value of 0101 is 5.
        Console.WriteLine((int)options);
    }
}

// optional한 값으로 사용하여 해당 flag 값이 적용되면 option을 추가할 수 있다.

--------------------------------------------------------------------------------
7. float(실수형)

- 근사 범위 -3.4 x 10(38) ~ 3.4 x 10(38) 전체 자릿수 7개 자릿수

float x = 3.5F; // 오른쪽 실수형 숫자는 double로 기본적으로 처리 되지만 F 또는 f를 뒤에 붙임으로 float형이 된다.

- 변환

int x = 3;         
float y = 4.5f;
short z = 5;
var result = x * y / z;              // 최종 실수형이 float형
Console.WriteLine("The result is {0}", result); // 2.7
Type type = result.GetType(); // result의 type
Console.WriteLine("result is of type {0}), type.ToString()); // System.Single - Single == float

----------------------------------------------------------------------------------
8. int (부호 있는 32 bit 정수형)

범위 -2,147,483,648 ~ 2,147,483,647

- 변환

float k = 3; // int형에서 long, float, double 또는 decimal로의 미리 정의된 암시적 변환 ok
             // sbyte, byte, short, ushort 또는 char에서 int로의 암시적 변환이 미리 정의되어 있습니다. 

int i = (int)3.0f; // 부동 소수점 형식에서 int로의 암시적 변환은 없습니다.


-----------------------------------------------------------------------------------
9. long (부호 있는 64bit 정수)

범위 -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807

long long1 = 4294967296; // int, uint, long, ulong 중에서 첫째 형식입니다. 
                         // 앞의 예제에서 정수 리터럴의 형식은 uint의 범위를 초과하기 때문에 long입니다.
                         // 유추해 볼 수 있는 것은 uint의 범위라면 type casting이 될 수 있다는 점입니다.

L이라는 접미사를 사용하는데, 오버로딩 된 메소드에 사용할 수 있습니다.

SimpleMethod(12); // int
SimpleMethod(12L); // long

- 변환

long에서 float, double 또는 decimal로의 암시적 변환이 미리 정의되어 있습니다.

int x = L; // 암시적캐스팅 불허
int x = (int)L; // OK 명시적 캐스팅

long x = 3.0; // 암시적캐스팅 불허
long y = (long)3.0; // OK

----------------------------------------------------------------------------------------
10. sbyte (부호 있는 정수)

범위 -128 ~ 127

// 오버로딩
SampleMethod(5); // int
SampleMethod((sbyte)5); // sbyte

- 변환
long에서 float, double 또는 decimal로의 암시적 변환이 미리 정의되어 있습니다.

sbyte z = x + y; // x와 y가 sbyte형이라도 산술연산은 int형으로 진행되므로

sbyte z = (sbyte)(x + y); // 산술 연산된 값에 sbyte형으로 명시적 캐스팅을 해주어야 함.

대상 저장소가 더 클 경우

int m = x + y;
long n = x + y; // 이렇게 사용할 수 있음. 암시적 형변환 가능.

부동 소수점에서 암시적 형변환은 없음.

sbyte y = (sbyte)3.0;

-------------------------------------------------------------------------------------
11. short (부호 있는 16비트 정수)

범위 -32,768 ~ 32,767

short x = 32767; // 초기화 시 int형에서 암시적 변환

// 오버로딩
SampleMethod((short)5);

- 변환

short에서 int, long, float, double 또는 decimal로의 미리 정의된 암시적 변환이 있습니다.

short z = x + y; // int형으로 연산 되므로 일반적으로는 암시적 변환이 되지 않음.
short z = (short)(x + y);

저장소가 크다면 가능
int m = x + y;
long n = x + y;

부동 소수점에서 암시적 형변환 없음.
short y = (short)3.0;

---------------------------------------------------------------------------------------
12 struct (구조체)

public struct Book
{
    public decimal price;
    public string title;
    public string author;
}

// 항목 특성이나 사각형의 좌표와 같은 관련 변수의 소규모 그룹을 캡슐화하는데 일반적으로 사용.

구조체는 생성자, 상수, 필드, 메서드, 속성, 인덱서, 연산자, 이벤트 및 중첩 형식도 포함할 수 있습니다. 

그러나 이러한 멤버가 여러 개 필요한 경우에는 구조체 대신 클래스 형식을 지정하는 것이 좋습니다.

상속이 되지 않으므로 접근자를 변경하여 사용할 수 없습니다.

---------------------------------------------------------------------------------------
13. uint (부호 없는 32비트 정수)

범위 0 ~ 4,294,967,295

u 또는 U 접미사를 사용할 수 있습니다.

Console.WriteLine(44U.GetType()); // System.UInt32
Console.WriteLine(323442434344U.GetType()); // System.UInt64, uint의 범위를 넘으면 자동 캐스팅

- 변환

uint에서 long, ulong, float, double 또는 decimal로의 미리 정의된 암시적 변환이 있습니다.

byte, ushort 또는 char에서 uint으로의 미리 정의된 암시적 변환이 있습니다. 

그 외의 다른 경우에는 명시적 변환을 사용해야 합니다.

uint y = (uint)3.0;

-------------------------------------------------------------------------------------
14. ulong (부호 없는 64비트 정수)

범위 0 ~ 18,446,744,073,709,551,615

접미사 l, L을 사용할 경우 ulong 또는 long이 된다. 1과 헷갈리기 때문에 L을 주로 사용.

접미사 u, U를 사용할 경우 크기에 따라 uint, ulong이 됨.

접미사 UL, ul, Ul, uL, LU, lu, Lu, lU 사용 시, ulong.

// 오버로딩
SampleMethod(5UL);

- 변환

ulong에서 float, double 또는 decimal로의 암시적 변환이 미리 정의되어 있습니다.

ulong에서 다른 정수 계열 형식으로의 암시적 변환은 없음.

byte, ushort, uint, char에서 ulong으로의 미리 정의된 암시적 변환이 있음.

부동 소수점에서 ulong으로의 암시적 변환은 없음.

ulong y = (ulong)3.0;

------------------------------------------------------------------------------------------
15. ushort (부호 없는 16비트 정수)

범위 0 ~ 65,535

ushort myShort = 65535; // int에서 ushort로 암시적 변환.

// 오버로드
SampleMethod((ushort)5);

- 변환

ushort z = x + y; // 암시적 변환은 에러가 남.

ushort z = (ushort)(x + y);

저장소 크기가 같거나 더 클 경우에는 사용 가능.

int m = x + y;
long n = x + y;

부동 소수점 type에서 ushort로의 암시적 변환은 없음.

ushort y = (ushort)3.0; // 명시적으로 변환해 주어야 함.

-----------------------------------------------------------------------